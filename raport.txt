/*
Podsumowanie wyników konkursu powinno zostać opisane w raporcie, który przedstawia czas działania każdego zespołu w różnych scenariuszach. Czas działania powinien być przedstawiony na czytelnych wykresach, na podstawie danych zbieranych przez obiekty klasy DefaultTimer. Dla każdego konkursu uzasadnij dlaczego konkretne drużyny były szybsze, a inne wolniejsze. Rozwiązania wielowątkowe powinny w uzasadnionych przypadkach być istotnie szybsze, jednak nie należy spodziewać się liniowego przyspieszenia w każdym z przypadków. Opisując wyniki uwzględnij rezultaty "CalcCollatzSoloTimer" dla różnych konkursów. W uzasadnieniu możesz również uwzględnić swoje własne timery, jeśli je dodasz. Eksperymenty należy przeprowadzić w dwóch różnych środowiskach np. komputer stacjonarny / laptop i maszyna students. Zadbaj o opis środowiska w raporcie, w szczególności model procesora wraz z liczbą rdzeni. Zwróć uwagę na różnice w wynikach które pojawią się przy wielokrotnym uruchamianiu programu. Idealny raport powinien zmieścić się na dwóch stronach a4. */

/* Wykresy:
- dopisać procesy z X
- śrdenia dla każdego size dla każdego teamu który ma size
- wszystko jeszcze na studentsie
"Zwróć uwagę na różnice w wynikach które pojawią się przy wielokrotnym uruchamianiu programu" */

W moim rozwiązaniu drużyny X zapisują każdy obliczony wynik (nie tylko ten ostateczny) do std::map. Zanim wywołają dalsze obliczenia dla liczby n, sprawdzają, czy wartość dla niej nie została już wcześniej obliczona i umieszczona w mapie. Chciałabym, żeby procesy z X przekazywały liczby do zapisania w std::map procesowi-korzeniowi za pomocą łączy nienazwanych, ale nie wiem, czy uda mi się to zaimplementować. Łatwiejsza wersja procesów z X jest taka, że korzystają one z tablicy N wartości i tylko dla nich zapisują wyniki (dla większych liczb nie).
Jeśli chodzi o zmiany w dostarczonych plikach, to dodałam atrybut bool share do klasy Team, żeby móc wygodniej odifowywać w runContest, czy mam go przeprowadzać dla drużyny z X czy bez X. share = true oznacza, że drużyna jest z X, share = false, że bez X.  
Swoje rozwiązanie testowałam na moim komputerze oraz studentsie (na tym drugim potrzebowałam komendy "ulimit -s 128"). 
Opis mojego komputera: 
Architektura:           x86_64
Tryb(y) pracy CPU:      32-bit, 64-bit
Kolejność bajtów:       Little Endian
CPU:                    8
Lista aktywnych CPU:    0-7
Wątków na rdzeń:        2
Rdzeni na gniazdo:      4
Gniazd:                 1
Węzłów NUMA:            1
ID producenta:          GenuineIntel
Rodzina CPU:            6
Model:                  142
Nazwa modelu:           Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz
Wersja:                 10
CPU MHz:                943.210
CPU max MHz:            3400,0000
CPU min MHz:            400,0000
BogoMIPS:               3600.00
Wirtualizacja:          VT-x
Cache L1d:              32K
Cache L1i:              32K
Cache L2:               256K
Cache L3:               6144K
Procesory węzła NUMA 0: 0-7
Opis środowiska students:
Architektura:                    x86_64
Tryb(y) pracy CPU:               32-bit, 64-bit
Kolejność bajtów:                Little Endian
Rozmiary adresów:                40 bits physical, 48 bits virtual
CPU:                             64
Lista aktywnych CPU:             0-63
Wątków na rdzeń:                 1
Rdzeni na gniazdo:               1
Gniazd:                          64
Węzłów NUMA:                     1
ID producenta:                   GenuineIntel
Rodzina CPU:                     6
Model:                           85
Nazwa modelu:                    Intel Xeon Processor (Skylake, IBRS)
Wersja:                          4
CPU MHz:                         2095.078
BogoMIPS:                        4190.15
Producent hipernadzorcy:         KVM
Typ wirtualizacji:               pełna
Cache L1d:                       2 MiB
Cache L1i:                       2 MiB
Cache L2:                        256 MiB
Cache L3:                        1 GiB
Procesory węzła NUMA 0:          0-63

Wykres1: Średni czas działania każdej drużyny na moim komputerze. 
Najwolniejsza drużyna to TeamNewProcesses. Tworzy ona bardzo dużo procesów od nowa, a tworzenie nowego procesu jest tak wolne, że całość wychodzi niemal dwa razy wolniej niż TeamSolo. Jest to jedyna drużyna wolniejsza niż TeamSolo, co wskazuje, że generalnie używanie wątków i procesów przyspiesza wykonanie programu (około dwukrotnie w średnim przypadku). TeamConstProcesses działa w podobnym czasie co TeamConstThreads i TeamPool. Prawdopodobnie dlatego, że tworzenie jedynie kilku procesów nie jest tak obciążające. TeamNewThreads działa od nich trochę szybciej. Wydaje mi się, że to dlatego, że w nim sprytnie czekam na to, który wątek pierwszy się zakończy. Czyli np. w TeamConstThreads jeden wątek może dostać getSize() bardzo prostych obliczeń, a inny getSize() bardzo trudnych, i wtedy praca nie będzie podzielona między nie równo. Jednak zdaje mi się, że TeamPool powinno działać szybciej, niż TeamNewThreads, a tymczasem działa ono w czasie podobnym do TeamConstThreads, może odrobinę szybciej. TeamAsync działa szybciej niż TeamNewThreads, ponieważ optymalniej gospodaruje wątkami. 

Wykres2: Średni czas działania drużyn bez X na moim komputerze. 

Wykres3: Średni czas działania drużyn z X na moim komputerze. 
Czas działania każdej z nich jest bardzo podobny, różnice są minimalne. Wszystkie działają istotnie szybciej, niż ich odpowiedniki z X. 



